# 0001. передача сущностей в ручку

## Дата
2025-07-15

## Статус
Частично реализовано

## Контекст
В проекте Telegram-бота используется собственный объект Context, предназначенный для передачи и централизованного хранения данных, актуальных на протяжении обработки одного запроса (Update).
Причины его появления:
- В хендлерах и вспомогательных функциях возникает необходимость обращаться к данным:
    - из Telegram-апдейта (message, callback_query, my_chat_member)
    - из базы данных (db_session)
    - из общего состояния FSM (fsm_state, fsm_data)
    - из бизнес-контекста (user, store, update_res)
- Передавать все эти значения через аргументы вручную — громоздко и неявно
- Используется много декораторов, и каждый из них может дополнять или читать контекст — это требует общего контейнера
- Некоторые данные (например, user, chat_id, user_id) часто используются в нескольких местах — и их не хочется извлекать повторно

Для этого был реализован объект Context
Класс содержит также свойства-помощники, такие как chat_id и user_id, которые извлекают нужные данные из update автоматически.

## Решение
Создан класс Context, инициализируемый при старте обработки каждого Update.
Объект передаётся по цепочке декораторов, хендлеров и вспомогательных функций.
Хранит:
    - ссылку на оригинальный Update
    - ссылку на AsyncSession базы данных
    - объект Store (бизнес-контекст)
    - состояние FSM и данные
    - ссылку на текущего пользователя (если она уже была получена)
    - ответ хендлера (update_res), если он устанавливается по ходу
    - "событие" (event), которое можно вручную переопределить (например, если в процессе происходит переключение контекста)
Свойства chat_id и user_id автоматически адаптируются под тип Update, что избавляет от if-ов в хендлерах.

## Альтернативы
1. **Передача параметров вручную**:
   - Плюсы: Простота реализации
   - Минусы: Громоздкость, дублирование кода, трудность поддержки
   
2. **Использование глобальных переменных**:
   - Плюсы: Простота доступа
   - Минусы: Проблемы с потокобезопасностью, сложность тестирования, плохая практика

## Последствия
**Положительные**:
- Контекст запроса централизован, передаётся везде как один объект — это упрощает сигнатуры функций
- Повторно используемые значения кэшируются в Context — нет необходимости многократно обращаться к базе или парсить update
- Context служит единым местом для расширения логики, связанной с текущим апдейтом (в будущем сюда можно добавить locale, permissions, bot_user, logging_context, и т.п.)

**Отрицательные**:
- Зависимость от кастомного объекта, что может затруднить понимание кода новыми разработчиками
- Потенциальная сложность отладки при проблемах с контекстом

## Ретроспектива
Решение показало свою эффективность в упрощении сигнатур функций. Однако стоит рассмотреть возможность документирования контекста более подробно для новых разработчиков.

## Связанные ADR
- 0006. Структура API

